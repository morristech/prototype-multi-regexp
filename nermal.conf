# Baseline, before any substitutions:
#
# - '%' is special marker for substitutions; to include raw '%', double it
# - Construct '$NAME(....)' specifies extraction; to include raw '$', #double it
#    - It is legal to nest extractions
# - Result of expanded matching definitions needs to be valid regexp, processor


# First, let's define custom substitutions:

# 'phrase' means non-space-sequence of characters; 'word' letters; 'num' digits
define %word -> \w+
define %phrase -> \S+
define %nr -> \d+
# more semantic macros, loosely defined
define %ts -> %phrase
define %ip -> %phrase
define %maybeUUID -> %phrase
define %hostname -> %phrase

define %ws -> \s+
define %optws -> \s*
define %any -> .*

# and one character replacement/shortcut for convenience

define ' ' -> %ws

# and then higher-level composition

# sample:
#<86>2015-05-12T20:57:53.302858+00:00 10.1.11.141 RealSource:    "10.1.63.172" Environment: "SFDC-IT" UUID: "NO" RawMsg: <86>May 12 20:57:53 sfm-jbhap-ls100 sshd[12973]: Accepted keyboard-interactive/pam for vgudidevuni.su from 10.3.42.185 port 58216 ssh2

define %base <%nr>$eventTimeStamp(%ts) $logAgent(%ip) RealSource: "$logSrcIp(%ip)" Environment: "$environment(%phrase)" UUID: "$uuid(maybeUUID)"\
 RawMsg: <%nr>$rawMsgTS(%word %num %phrase) $logSrcHostname(%hostname) $appname($word)[$appPID(%num)]:

extract sshdAcceptedSessionsLinux {
  pattern: %base ($authStatus(Accepted)) $sshAuthMethod(%phrase) for $user(%hostname) from $srcIP(%ip) port $srcPort(%nr) $sshProtocol(%phrase)
  append: { "service":"ssh", "logType":"security", "serviceType":"authentication", "vendor":"Redhat", "product":"Linux" }
}

extract sshdAcceptedSessionsBigIP { }

extract ASABuiltInboundNoUserID { }
extract ASABuiltInboundWithUserID { }
extract ASABuiltOutboundNoUserID { }
extract ASABuiltOutboundWithUserID { }
extract ASAVpnUrlLogWithUserID { }
extract ASAVpnUrlLogNoUserID { }
extract broProdHttp { }
extract ssgdWebtopStarted { }
extract ssgdEmulatorStarted { }
extract WindowsLogon4624 { }


#### end of sample crap
